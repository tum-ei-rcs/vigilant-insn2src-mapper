#!/usr/bin/python

# This script parses many outputs of simulavr2times and computes composite statistics.
#
# (C) 2018 Martin Becker <becker@rcs.ei.tum.de>

import sys
import getopt
import os
import ast
import pprint
import traceback
from time import strftime

# used to suppress output from subprocesses
FNULL = open(os.devnull, 'w')

exectimes = dict()  # maps function name to {'fun', 'bcet', 'wcet', 'valid', 'calls'}


def merge_times(thistime, testname):
    """merges thistime dictionary into exectimes dictionary"""
    global exectimes
    # pprint.pprint(thistime)
    try:
        if not exectimes:  # empty
            exectimes = thistime
            for k, v in exectimes.iteritems():
                v['test'] = testname
        else:
            # for each function in the dict...
            for key, value in thistime.iteritems():
                # else track min/max
                if key in exectimes:
                    # merge
                    if value['valid']:
                        if value['bcet'] < exectimes[key]['bcet']:
                            exectimes[key]['bcet'] = value['bcet']
                        if value['wcet'] > exectimes[key]['wcet']:
                            exectimes[key]['wcet'] = value['wcet']
                            exectimes[key]['test'] = testname
                        exectimes[key]['count'] = exectimes[key]['count'] + value['count']
                else:
                    exectimes[key] = value  # copy in this key
                    exectimes[key]['test'] = testname
    except:
        print "ERROR"
        print(traceback.format_exc())


def write_library(out, results, only_functions):
    assert isinstance(out, str)
    assert isinstance(results, dict)
    # --

    def is_in_libc(func):
        return not only_functions or func in only_functions

    with open(out, 'w') as f:
        f.write("""
# WCET library for cbb-analzer, generated by {}

[Target]
name=AtmegaXXX
timestamp={}
libc=avr-X.Y.Z
comment=these values are obtained by cycle-accurate simulations on gcc's test cases
""".format(__file__, strftime("%Y-%m-%d_%H:%M:%S")))
        f.write("\n[Entries]\n")
        for func in sorted(results):
            if not is_in_libc(func): continue
            data = results[func]
            f.write("{}={}  # from libc/test/{}\n".format(func, data['wcet'], data['test']))

    return 0


def read_and_merge_results(files):
    assert isinstance(files, list)
    # --

    def read_log(onefile):
        with open(onefile, 'r') as f:
            for line in f:
                # each line string was a dictionary back in the day...
                # turn string back into python dict...easier to digest ;)
                try:
                    thistime = ast.literal_eval(line)
                    if isinstance(thistime, dict):
                        return thistime
                except:
                    pass
        return {}

    for f in files:
        print "Parsing {} ...".format(f)
        thistime = read_log(f)
        if not thistime:
            print "ERROR: no results from test {}".format(f)
        else:
            merge_times(thistime, f)
    return exectimes


def read_func_file(fil):
    """Read list of functions that we are interested in"""
    funcs = set()
    if fil is not None:
        with open(fil, 'r') as f:
            for line in f:
                funcs.add(line.strip())
    return funcs


def main(argv):
    out = 'wcet.lib'
    funcfile = None
    try:
        opts, args = getopt.getopt(argv, "o:f:", ["output=", "functions="])
    except getopt.GetoptError:
        print __file__ + '-o <outfile> -f <functions-file> <logfile>+'
        sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            print 'try_input_variants.py -e <elf> -n <how many>'
            sys.exit()
        elif opt in ("-o", "--outfile"):
            out = arg
        elif opt in ("-f", "--functions"):
            funcfile = arg

    results = read_and_merge_results(args)
    if not results:
        print "ERROR reading results"
        return 1
    print "Results:"
    pprint.pprint(results)
    only_functions = read_func_file(funcfile)
    ret = write_library(out, results, only_functions)
    print "Done, library={}".format(out)
    exit(ret)


if __name__ == "__main__":
    main(sys.argv[1:])
